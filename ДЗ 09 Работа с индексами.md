# Домашнее задание: Работа с индексами в PostgreSQL

## Цель

- Знать и уметь применять основные виды индексов PostgreSQL  
- Строить и анализировать план выполнения запроса  
- Уметь оптимизировать запросы с использованием индексов

---

## Исходные данные

Используемая таблица: `orders`  
Структура таблицы:

```sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    customer_id INTEGER,
    order_date DATE,
    status TEXT,
    total_amount NUMERIC,
    description TEXT
);
```
Заполнил тестовыми данными на 10000 строк
```sql
INSERT INTO orders (customer_id, order_date, status, total_amount, description)
SELECT 
    floor(random() * 100 + 1)::integer AS customer_id,
    (DATE '2020-01-01' + (random() * (DATE '2024-12-31' - DATE '2020-01-01'))::integer) AS order_date,
    (ARRAY['pending', 'processed', 'shipped', 'delivered', 'cancelled'])[floor(random() * 5 + 1)] AS status,
    (random() * 1000 + 1)::numeric(10,2) AS total_amount,
    'Order description ' || generate_series(1, 10000) AS description
FROM generate_series(1, 10000);
END $$;

```
---

## 1. Индекс на поле `order_date`

```sql
CREATE INDEX idx_order_date ON orders(order_date);
```

**Комментарий:**  
Этот индекс нужен для ускорения фильтрации заказов по дате.

### Пример запроса:

```sql
EXPLAIN ANALYZE
SELECT * FROM orders
WHERE order_date >= '2024-01-01' AND order_date <= '2024-12-31';
```

**Фрагмент плана выполнения:**

```
Bitmap Heap Scan on orders
  Recheck Cond: ((order_date >= '2024-01-01'::date) AND (order_date <= '2024-12-31'::date))
  ->  Bitmap Index Scan on idx_order_date
        Index Cond: ((order_date >= '2024-01-01'::date) AND (order_date <= '2024-12-31'::date))
```

**Вывод:**  
Индекс используется, ускоряет поиск по диапазону дат.

---

## 2. Полнотекстовый поиск по полю `description`

```sql
CREATE INDEX idx_description_fts
ON orders
USING GIN (to_tsvector('russian', description));
```

**Комментарий:**  
Индекс GIN по функции `to_tsvector` позволяет быстро искать заказы по ключевым словам в описании.

### Пример запроса:

```sql
EXPLAIN ANALYZE
SELECT * FROM orders
WHERE to_tsvector('russian', description) @@ plainto_tsquery('доставка');
```

**Фрагмент плана выполнения:**

```
Bitmap Heap Scan on orders
  Recheck Cond: (to_tsvector('russian'::regconfig, description) @@ plainto_tsquery('доставка'::text))
  ->  Bitmap Index Scan on idx_description_fts
        Index Cond: (to_tsvector('russian'::regconfig, description) @@ plainto_tsquery('доставка'::text))
```

**Вывод:**  
Запрос по ключевым словам в `description` теперь значительно быстрее благодаря GIN-индексу.

---

## 3. Индекс на выражение: длина описания

```sql
CREATE INDEX idx_description_length
ON orders ((length(description)));
```

**Комментарий:**  
Индекс на функцию `length(description)` помогает в запросах, где фильтрация идет по длине текста.

### Пример запроса:

```sql
EXPLAIN ANALYZE
SELECT * FROM orders
WHERE length(description) > 1000;
```

**Фрагмент плана выполнения:**

```
Bitmap Heap Scan on orders
  Recheck Cond: (length(description) > 1000)
  ->  Bitmap Index Scan on idx_description_length
        Index Cond: (length(description) > 1000)
```

**Вывод:**  
Функциональный индекс помогает при специфических фильтрациях, таких как длина текста.

---

## 4. Индекс на часть таблицы (частичный индекс)

```sql
CREATE INDEX idx_orders_pending
ON orders(status)
WHERE status = 'pending';
```

**Комментарий:**  
Частичный индекс ускоряет выборку заказов в статусе "pending", не затрагивая остальные строки.

### Пример запроса:

```sql
EXPLAIN ANALYZE
SELECT * FROM orders
WHERE status = 'pending';
```

**Фрагмент плана выполнения:**

```
Index Scan using idx_orders_pending on orders
  Index Cond: (status = 'pending')
```

**Вывод:**  
Такой индекс эффективен, когда поле имеет небольшое количество часто используемых значений.

---

## 5. Составной индекс по `customer_id` и `status`

```sql
CREATE INDEX idx_customer_status
ON orders(customer_id, status);
```

**Комментарий:**  
Составной индекс полезен, когда в запросах используются оба поля, например, при фильтрации заказов клиента по статусу.

### Пример запроса:

```sql
EXPLAIN ANALYZE
SELECT * FROM orders
WHERE customer_id = 123 AND status = 'completed';
```

**Фрагмент плана выполнения:**

```
Index Scan using idx_customer_status on orders
  Index Cond: ((customer_id = 123) AND (status = 'completed'))
```

**Вывод:**  
Составной индекс уменьшает число возвращаемых строк и ускоряет выполнение запроса.

---

## С какими проблемами столкнулся

- **Выбор типа индекса**: не всегда очевидно, использовать ли B-tree или GIN, особенно при полнотекстовом поиске.
- **Планировщик может не использовать индекс**, если таблица слишком мала или статистика не обновлена. Помогает `ANALYZE`.
- **Ошибки с частичными индексами**: если забыть указать условие в WHERE — индекс не применяется.

---

## Заключение

Создание подходящих индексов значительно ускоряет выполнение запросов. Главное — анализировать типы запросов и понимать, какие поля участвуют в фильтрации, сортировке или поиске. Важно помнить про обновление статистики (`ANALYZE`) и отслеживать планы запросов (`EXPLAIN ANALYZE`).

---
```
