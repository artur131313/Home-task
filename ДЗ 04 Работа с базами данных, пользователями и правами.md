# Практическая работа: Работа с базами данных, пользователями и правами

## Цель
- Создание новой базы данных, схемы и таблицы
- Создание роли для чтения данных из созданной схемы
- Создание роли для чтения и записи данных из созданной схемы

---

## Пошаговая инструкция

1. **Создайте новый кластер PostgreSQL 14**

2. **Зайдите в кластер под пользователем `postgres`**

3. **Создайте новую базу данных `testdb`**  
   ```sql
   CREATE DATABASE testdb;
   ```

4. **Подключитесь к `testdb` под пользователем `postgres`**

5. **Создайте новую схему `testnm`**  
   ```sql
   CREATE SCHEMA testnm;
   ```

6. **Создайте таблицу `t1` с одной колонкой `c1` типа integer**  
   ```sql
   CREATE TABLE t1 (c1 integer);
   ```

7. **Вставьте строку со значением `c1 = 1`**  
   ```sql
   INSERT INTO t1 VALUES (1);
   ```

8. **Создайте новую роль `readonly`**  
   ```sql
   CREATE ROLE readonly;
   ```

9. **Дайте роли `readonly` право на подключение к базе `testdb`**  
   ```sql
   GRANT CONNECT ON DATABASE testdb TO readonly;
   ```

10. **Дайте роли `readonly` право на использование схемы `testnm`**  
    ```sql
    GRANT USAGE ON SCHEMA testnm TO readonly;
    ```

11. **Дайте роли `readonly` право на `SELECT` всех таблиц схемы `testnm`**  
    (Пока таблица в схеме по умолчанию — это не сработает!)  
    ```sql
    GRANT SELECT ON ALL TABLES IN SCHEMA testnm TO readonly;
    ```

12. **Создайте пользователя `testread` с паролем `test123`**  
    ```sql
    CREATE USER testread WITH PASSWORD 'test123';
    ```

13. **Назначьте пользователю роль `readonly`**  
    ```sql
    GRANT readonly TO testread;
    ```

14. **Зайдите под пользователем `testread` в базу данных `testdb`**

15. **Попробуйте выполнить `SELECT * FROM t1;`**  
    ❌ **Ошибка**: доступ запрещён или таблица не найдена.  
    Причина: таблица `t1` была создана в схеме `public`, а права даны на схему `testnm`.

16. **Посмотрите список таблиц**  
    ```sql
    \dt *.*
    ```

17. **Вернитесь в `testdb` под пользователем `postgres`**

18. **Удалите таблицу `t1`**
    ```sql
    DROP TABLE t1;
    ```

19. **Создайте таблицу заново, указав явно схему `testnm`**  
    ```sql
    CREATE TABLE testnm.t1 (c1 integer);
    ```

20. **Вставьте строку со значением `c1 = 1`**  
    ```sql
    INSERT INTO testnm.t1 VALUES (1);
    ```

21. **Зайдите под пользователем `testread` в базу данных `testdb`**

22. **Выполните `SELECT * FROM testnm.t1;`**  
    ✅ **Получилось!**  
    Причина: теперь таблица находится в схеме, на которую даны права.

23. **Как избежать таких проблем в будущем?**  
    - **Всегда указывайте схему при создании объектов**
    - **Можно задать search_path**
      ```sql
      ALTER ROLE testread SET search_path = testnm;
      ```

24. **Выполните снова `SELECT * FROM testnm.t1;`**  
    ✅ Всё работает

25. **Попробуйте создать таблицу и вставить данные:**  
    ```sql
    CREATE TABLE t2(c1 integer);
    INSERT INTO t2 VALUES (2);
    ```
    ❌ **Получилось?**  
    Да, если права на схему по умолчанию `public` не были ограничены!

26. **Почему это возможно?**  
    - В `public` по умолчанию все пользователи имеют право создавать объекты.
    - Надо убрать лишние права:
      ```sql
      REVOKE CREATE ON SCHEMA public FROM PUBLIC;
      ```

27. **Теперь попробуйте:**  
    ```sql
    CREATE TABLE t3(c1 integer);
    INSERT INTO t2 VALUES (2);
    ```
    ❌ Ошибка: нет прав на создание таблиц  
    ✅ Ожидаемое поведение

---

## Выводы

- Таблицы должны быть созданы в схемах, к которым вы явно предоставляете доступ.
- Использование схем и прав доступа — важная часть безопасной работы с PostgreSQL.
- По умолчанию схема `public` даёт слишком много прав, её нужно ограничивать.
