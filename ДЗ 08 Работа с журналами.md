# Практическая работа: Работа с журналами

## Цель работы

- **Работа с WAL и контрольными точками:**  
  Научиться работать с журналами (WAL) PostgreSQL, настраивать параметры их формирования и контроля, а также изучать статистику работы контрольных точек.

- **Нагрузочное тестирование и анализ производительности:**  
  Использовать утилиту pgbench для создания нагрузки, измерения объема сгенерированных журналов и расчета среднего объема, приходящегося на каждую контрольную точку.

- **Понимание влияния режимов подтверждения транзакций:**  
  Сравнить производительность (TPS) в синхронном и асинхронном режимах работы подтверждения транзакций, объяснить полученные результаты.

- **Работа с контрольными суммами страниц:**  
  Создать кластер с включенной проверкой контрольных сумм страниц, внести изменения в данные, проанализировать обнаружение ошибок и способы их обхода.

## Задание

1. **Настройка контрольных точек:**  
   Настроить выполнение контрольной точки каждые 30 секунд (параметр `checkpoint_timeout`).

2. **Нагрузочное тестирование с pgbench:**  
   Подать нагрузку с помощью pgbench в течение 10 минут и измерить сгенерированный объем WAL-файлов.

3. **Оценка WAL на контрольную точку:**  
   Определить, какой объем WAL приходится в среднем на одну контрольную точку, используя статистику (например, из `pg_stat_bgwriter`).

4. **Анализ работы контрольных точек:**  
   Проверить, выполнялись ли контрольные точки строго по расписанию. Объяснить возможные отклонения (например, связанные с интенсивностью операций или параметрами кластера).

5. **Сравнение режимов подтверждения транзакций:**  
   Сравнить TPS в синхронном (по умолчанию) и асинхронном режимах (при отключении синхронного подтверждения) с использованием pgbench.

6. **Эксперимент с кластером с контрольными суммами страниц:**
   - Инициализировать новый кластер с опцией `--data-checksums`.
   - Создать таблицу, вставить несколько записей.
   - Выключить кластер, изменить пару байт в файле, связанном с таблицей (причинно нарушить целостность данных).
   - Запустить кластер и выполнить выборку из таблицы.
   - Проанализировать полученную ошибку.

7. **Обход ошибки поврежденных страниц:**  
   Рассмотреть, как можно проигнорировать ошибку (с помощью параметра `zero_damaged_pages`) и продолжить работу, понимая последствия такого подхода.

## Практическая часть

### Шаг 1. Настройка контрольных точек

В конфигурационном файле `postgresql.conf` изменил параметры, связанные с контрольными точками:

```conf
# Задание интервала между контрольными точками
checkpoint_timeout = 30s
# Параметр, определяющий долю времени, за которую контрольная точка должна быть завершена
checkpoint_completion_target = 0.9
```

После внесения изменений перезапустил кластер PostgreSQL:

```bash
sudo systemctl restart postgresql
```

### Шаг 2. Проведение нагрузочного тестирования с pgbench

Инициализировал базу данных:

```bash
sudo -u postgres pgbench -i -s 10 mydb
```

Запустил тестовую нагрузку на 10 минут (600 секунд) с 10 параллельными клиентами:

```bash
sudo -u postgres pgbench -c 10 -T 600 mydb
```

### Шаг 3. Измерение объема WAL-файлов

После завершения теста оцените объем сгенерированных WAL-файлов. Обычно они находятся в каталоге `pg_wal` (в PostgreSQL 10 и выше):

```bash
sudo du -sh /var/lib/postgresql/<версия>/main/pg_wal
```

Полученный размер - 129M.

Чтобы оценить, какой объем WAL приходится на одну контрольную точку, необходимо узнать количество контрольных точек. Это можно сделать с помощью запроса:

```sql
SELECT checkpoints_timed, checkpoints_req FROM pg_stat_bgwriter;
```
![image](https://github.com/user-attachments/assets/1cafb33b-a7e1-4d71-8f61-08e87c536f41)

Где:
- `checkpoints_timed` — количество контрольных точек, запущенных по истечению времени,
- `checkpoints_req` — количество контрольных точек, инициированных при переполнении WAL.

Средний объем WAL на одну контрольную точку вычисляется как:

```
(Общий объем WAL) / (checkpoints_timed + checkpoints_req)
129 / (150 + 3) = 0,84

```

### Шаг 4. Анализ статистики контрольных точек

Проверьте, выполнялись ли контрольные точки строго каждые 30 секунд. На практике могут быть отклонения, так как:
- PostgreSQL может инициировать контрольную точку преждевременно при резком увеличении объема записей, чтобы не допустить переполнения WAL.
- Другие параметры, такие как `max_wal_size` и `min_wal_size`, а также текущая нагрузка, влияют на момент запуска контрольной точки.
- Параметр `checkpoint_completion_target` распределяет нагрузку по записи данных, что также может влиять на время завершения.

### Шаг 5. Сравнение TPS в синхронном и асинхронном режимах

Для сравнения запустите pgbench дважды:

#### Синхронный режим (по умолчанию)

```bash
pgbench -c 10 -T 600 mydb
```

#### Асинхронный режим

Выключите синхронное подтверждение транзакций. Это можно сделать на уровне сессии или на уровне системы. Например, изменить глобально:

```sql
ALTER SYSTEM SET synchronous_commit TO 'off';
```

Перезапустите PostgreSQL:

```bash
sudo systemctl restart postgresql
```

Запустите pgbench повторно:

```bash
pgbench -c 10 -T 600 mydb
```

**Ожидаемый результат:**
- **TPS в асинхронном режиме** – как правило, выше, поскольку транзакции завершаются быстрее без ожидания подтверждения записи на диск.
- **Риски:** В случае сбоя возможно потеря последних несинхронно подтвержденных транзакций.

#### Комментарий по результатам

Повышение TPS в асинхронном режиме достигается за счет уменьшения задержек, однако это жертвует гарантией сохранности данных в критических ситуациях.

### Шаг 6. Создание нового кластера с включенной контрольной суммой страниц

Инициализируйте новый кластер с включением контрольных сумм страниц (данная опция доступна при инициализации базы данных):

```bash
pg_ctl initdb -D /path/to/new_cluster --data-checksums
```

Запустите новый кластер:

```bash
pg_ctl -D /path/to/new_cluster start
```

Подключитесь к новому кластеру и создайте таблицу:

```sql
CREATE TABLE test_page_checksum (
    id serial PRIMARY KEY,
    data text
);

INSERT INTO test_page_checksum (data) VALUES ('тестовое значение 1'), ('тестовое значение 2');
```

### Шаг 7. Повреждение данных

1. **Выключите кластер:**

   ```bash
   pg_ctl -D /path/to/new_cluster stop
   ```

2. **Определите файл, связанный с таблицей.**  
   Для этого выполните запрос, чтобы узнать `relfilenode` таблицы:

   ```sql
   SELECT relfilenode FROM pg_class WHERE relname = 'test_page_checksum';
   ```

   Найдите соответствующий файл в каталоге `base/<OID>` (где `<OID>` — идентификатор, полученный из запроса).

3. **Измените пару байт в файле.**  
   Например, с помощью утилиты `dd` можно выполнить:

   ```bash
   dd if=/dev/zero bs=1 seek=<смещение> count=2 conv=notrunc of=/path/to/new_cluster/base/<OID>
   ```

   Здесь `<смещение>` — позиция в файле, где необходимо изменить данные.

4. **Запустите кластер снова:**

   ```bash
   pg_ctl -D /path/to/new_cluster start
   ```

### Шаг 8. Выборка данных и анализ ошибки

Выполните запрос для выборки данных:

```sql
SELECT * FROM test_page_checksum;
```

**Результат:**  
Если изменение байт привело к нарушению контрольной суммы, PostgreSQL обнаружит несоответствие и выдаст ошибку, например:

```
ERROR:  page verification failed, calculated checksum does not match stored value
```

**Объяснение:**  
Контрольные суммы страниц используются для выявления повреждений. При изменении данных без пересчета контрольной суммы возникает несоответствие, которое и обнаруживается сервером.

#### Обход ошибки

Чтобы проигнорировать ошибку повреждённой страницы и продолжить работу, можно установить для текущей сессии параметр:

```sql
SET zero_damaged_pages = on;
```

При установленном параметре PostgreSQL заменит поврежденные данные нулями и продолжит выполнение запроса.  
**Важно:** Такой подход допустим только в экстренных случаях, так как он приводит к потере данных.

## Выводы и рекомендации

- **Контрольные точки:**  
  Несмотря на настройку на выполнение раз в 30 секунд, контрольные точки могут запускаться раньше или позже, в зависимости от текущей нагрузки, объема записей и других параметров кластера (например, `max_wal_size` и `min_wal_size`).

- **Режимы подтверждения транзакций:**  
  Асинхронный режим (synchronous_commit = off) позволяет добиться более высокой производительности (TPS) за счет отказа от ожидания гарантированной записи на диск, но в этом случае увеличивается риск потери последних транзакций при сбое.

- **Контрольные суммы страниц:**  
  Включение контрольных сумм позволяет оперативно выявлять повреждения на уровне страниц, что повышает надежность работы базы данных. Однако при обнаружении повреждений PostgreSQL не сможет прочитать поврежденные страницы, что приводит к ошибкам.

- **zero_damaged_pages:**  
  Установка параметра `zero_damaged_pages` позволяет пропустить чтение поврежденных страниц, заменяя их нулями. Этот параметр следует использовать исключительно в ситуациях, когда необходимо срочно получить доступ к данным (например, для спасения информации), поскольку данные на поврежденных страницах будут утеряны.

## Заключение

Данная практическая работа помогает:
- Понять, как настраиваются и работают контрольные точки в PostgreSQL.
- Оценить влияние интенсивности записи на генерацию WAL.
- Сравнить производительность в разных режимах подтверждения транзакций.
- Осознать важность контрольных сумм страниц для сохранения целостности данных и ознакомиться с методами обхода ошибок в случае их повреждения.
```

---
