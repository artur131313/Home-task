# Практическая работа: Работа с журналами

## Цель работы

- **Работа с WAL и контрольными точками:**  
  Научиться работать с журналами (WAL) PostgreSQL, настраивать параметры их формирования и контроля, а также изучать статистику работы контрольных точек.

- **Нагрузочное тестирование и анализ производительности:**  
  Использовать утилиту pgbench для создания нагрузки, измерения объема сгенерированных журналов и расчета среднего объема, приходящегося на каждую контрольную точку.

- **Понимание влияния режимов подтверждения транзакций:**  
  Сравнить производительность (TPS) в синхронном и асинхронном режимах работы подтверждения транзакций, объяснить полученные результаты.

- **Работа с контрольными суммами страниц:**  
  Создать кластер с включенной проверкой контрольных сумм страниц, внести изменения в данные, проанализировать обнаружение ошибок и способы их обхода.

## Задание

1. **Настройка контрольных точек:**  
   Настроить выполнение контрольной точки каждые 30 секунд (параметр `checkpoint_timeout`).

2. **Нагрузочное тестирование с pgbench:**  
   Подать нагрузку с помощью pgbench в течение 10 минут и измерить сгенерированный объем WAL-файлов.

3. **Оценка WAL на контрольную точку:**  
   Определить, какой объем WAL приходится в среднем на одну контрольную точку, используя статистику (например, из `pg_stat_bgwriter`).

4. **Анализ работы контрольных точек:**  
   Проверить, выполнялись ли контрольные точки строго по расписанию. Объяснить возможные отклонения (например, связанные с интенсивностью операций или параметрами кластера).

5. **Сравнение режимов подтверждения транзакций:**  
   Сравнить TPS в синхронном (по умолчанию) и асинхронном режимах (при отключении синхронного подтверждения) с использованием pgbench.

6. **Эксперимент с кластером с контрольными суммами страниц:**
   - Инициализировать новый кластер с опцией `--data-checksums`.
   - Создать таблицу, вставить несколько записей.
   - Выключить кластер, изменить пару байт в файле, связанном с таблицей (причинно нарушить целостность данных).
   - Запустить кластер и выполнить выборку из таблицы.
   - Проанализировать полученную ошибку.

7. **Обход ошибки поврежденных страниц:**  
   Рассмотреть, как можно проигнорировать ошибку (с помощью параметра `zero_damaged_pages`) и продолжить работу, понимая последствия такого подхода.

## Практическая часть

### Шаг 1. Настройка контрольных точек

В конфигурационном файле `postgresql.conf` изменил параметры, связанные с контрольными точками:

```conf
# Задание интервала между контрольными точками
checkpoint_timeout = 30s
# Параметр, определяющий долю времени, за которую контрольная точка должна быть завершена
checkpoint_completion_target = 0.9
```

После внесения изменений перезапустил кластер PostgreSQL:

```bash
sudo systemctl restart postgresql
```

### Шаг 2. Проведение нагрузочного тестирования с pgbench

Инициализировал базу данных:

```bash
sudo -u postgres pgbench -i -s 10 postgres
```

Запустил тестовую нагрузку на 10 минут (600 секунд) с 10 параллельными клиентами:

```bash
sudo -u postgres pgbench -c 10 -T 600 postgres
```

### Шаг 3. Измерение объема WAL-файлов

После завершения теста оцените объем сгенерированных WAL-файлов. Обычно они находятся в каталоге `pg_wal` (в PostgreSQL 10 и выше):

```bash
sudo du -sh /var/lib/postgresql/14/main/pg_wal
```

Полученный размер - 305M.

Чтобы оценить, какой объем WAL приходится на одну контрольную точку, необходимо узнать количество контрольных точек. Это можно сделать с помощью запроса:

```sql
SELECT checkpoints_timed, checkpoints_req FROM pg_stat_bgwriter;
```
![image](https://github.com/user-attachments/assets/602cf339-f70b-4aac-aac4-28e76941ed6e)


Где:
- `checkpoints_timed` — количество контрольных точек, запущенных по истечению времени,
- `checkpoints_req` — количество контрольных точек, инициированных при переполнении WAL.

Средний объем WAL на одну контрольную точку вычисляется как:

```
(Общий объем WAL) / (checkpoints_timed + checkpoints_req)
305 / (335 + 6) = 0,89

```
Нормальный диапазон:
    70–90% — типично для систем с умеренной или высокой нагрузкой.
    <50% — контрольные точки могут работать неэффективно (например, из-за слишком частого срабатывания).
    >90% — WAL почти полностью заполняется перед контрольной точкой, что может приводить к принудительным checkpoint (checkpoints_req).

0.89 или 89%:
Хороший показатель — система успевает обрабатывать WAL без переполнения.
Но близко к верхней границе — если значение часто достигает >90%, возможны принудительные контрольные точки.


### Шаг 4. Анализ статистики контрольных точек

![image](https://github.com/user-attachments/assets/4a2fcc61-b633-428e-9e69-7297ec0a20a6)

checkpoint_write_time = 588561 (мс ≈ 588.5 сек)
      Общее время, затраченное на запись данных на диск за все контрольные точки.
      
      Среднее на контрольную точку: 588561 мс / (367 + 6) ≈ 1578 мс (1.58 сек).
      Оценка: Если это значение растет, возможны проблемы с диском (медленный I/O, высокая нагрузка). Для оптимизации можно:
      
      Увеличить checkpoint_completion_target (если сейчас <0.9).
      Проверить диск (перейти на SSD, настроить RAID).

checkpoint_sync_time = 1014 (мс ≈ 1.01 сек)
      Общее время синхронизации данных (fsync).
      
      Среднее на контрольную точку: 1014 мс / 373 ≈ 2.7 мс.
      Оценка: Очень низкое значение — система эффективно синхронизирует данные. Если бы оно было высоким (например, >100 мс на контрольную точку), это указывало бы на проблемы с диском.

buffers_checkpoint = 212053
      Общее количество буферов, записанных за все контрольные точки.
      
      Среднее на контрольную точку: 212053 / 373 ≈ 568 буферов (1 буфер = 8 КБ → ~4.4 МБ данных).
      Оценка: Умеренная нагрузка. Если значение резко возрастает, возможно, увеличилась активность записи в БД.      


### Шаг 5. Сравнение TPS в синхронном и асинхронном режимах

Для сравнения запустил pgbench дважды:

#### Синхронный режим (по умолчанию)

```bash
sudo -u postgres pgbench -i -s 10 postgres
```
![image](https://github.com/user-attachments/assets/a1a3fe17-fff7-4300-909b-67ec99c8934f)


#### Асинхронный режим

Выключил синхронное подтверждение транзакций. Это можно сделать на уровне сессии или на уровне системы. Например, изменить глобально:

```sql
ALTER SYSTEM SET synchronous_commit TO 'off';
```

Перезапустите PostgreSQL:

```bash
sudo systemctl restart postgresql
```

Запустил pgbench повторно:

```bash
sudo -u postgres pgbench -i -s 10 postgres
```

**Ожидаемый результат:**
- **TPS в асинхронном режиме** – как правило, выше, поскольку транзакции завершаются быстрее без ожидания подтверждения записи на диск.
- **Риски:** В случае сбоя возможно потеря последних несинхронно подтвержденных транзакций.

#### Комментарий по результатам

Повышение TPS в асинхронном режиме достигается за счет уменьшения задержек, однако это жертвует гарантией сохранности данных в критических ситуациях.

### Шаг 6. Создание нового кластера с включенной контрольной суммой страниц

Инициализируйте новый кластер с включением контрольных сумм страниц (данная опция доступна при инициализации базы данных):

```bash
pg_ctl initdb -D /path/to/new_cluster --data-checksums
```

Запустите новый кластер:

```bash
pg_ctl -D /path/to/new_cluster start
```

Подключитесь к новому кластеру и создайте таблицу:

```sql
CREATE TABLE test_page_checksum (
    id serial PRIMARY KEY,
    data text
);

INSERT INTO test_page_checksum (data) VALUES ('тестовое значение 1'), ('тестовое значение 2');
```

### Шаг 7. Повреждение данных

1. **Выключите кластер:**

   ```bash
   pg_ctl -D /path/to/new_cluster stop
   ```

2. **Определите файл, связанный с таблицей.**  
   Для этого выполните запрос, чтобы узнать `relfilenode` таблицы:

   ```sql
   SELECT relfilenode FROM pg_class WHERE relname = 'test_page_checksum';
   ```

   Найдите соответствующий файл в каталоге `base/<OID>` (где `<OID>` — идентификатор, полученный из запроса).

3. **Измените пару байт в файле.**  
   Например, с помощью утилиты `dd` можно выполнить:

   ```bash
   dd if=/dev/zero bs=1 seek=<смещение> count=2 conv=notrunc of=/path/to/new_cluster/base/<OID>
   ```

   Здесь `<смещение>` — позиция в файле, где необходимо изменить данные.

4. **Запустите кластер снова:**

   ```bash
   pg_ctl -D /path/to/new_cluster start
   ```

### Шаг 8. Выборка данных и анализ ошибки

Выполните запрос для выборки данных:

```sql
SELECT * FROM test_page_checksum;
```

**Результат:**  
Если изменение байт привело к нарушению контрольной суммы, PostgreSQL обнаружит несоответствие и выдаст ошибку, например:

```
ERROR:  page verification failed, calculated checksum does not match stored value
```

**Объяснение:**  
Контрольные суммы страниц используются для выявления повреждений. При изменении данных без пересчета контрольной суммы возникает несоответствие, которое и обнаруживается сервером.

#### Обход ошибки

Чтобы проигнорировать ошибку повреждённой страницы и продолжить работу, можно установить для текущей сессии параметр:

```sql
SET zero_damaged_pages = on;
```

При установленном параметре PostgreSQL заменит поврежденные данные нулями и продолжит выполнение запроса.  
**Важно:** Такой подход допустим только в экстренных случаях, так как он приводит к потере данных.

## Выводы и рекомендации

- **Контрольные точки:**  
  Несмотря на настройку на выполнение раз в 30 секунд, контрольные точки могут запускаться раньше или позже, в зависимости от текущей нагрузки, объема записей и других параметров кластера (например, `max_wal_size` и `min_wal_size`).

- **Режимы подтверждения транзакций:**  
  Асинхронный режим (synchronous_commit = off) позволяет добиться более высокой производительности (TPS) за счет отказа от ожидания гарантированной записи на диск, но в этом случае увеличивается риск потери последних транзакций при сбое.

- **Контрольные суммы страниц:**  
  Включение контрольных сумм позволяет оперативно выявлять повреждения на уровне страниц, что повышает надежность работы базы данных. Однако при обнаружении повреждений PostgreSQL не сможет прочитать поврежденные страницы, что приводит к ошибкам.

- **zero_damaged_pages:**  
  Установка параметра `zero_damaged_pages` позволяет пропустить чтение поврежденных страниц, заменяя их нулями. Этот параметр следует использовать исключительно в ситуациях, когда необходимо срочно получить доступ к данным (например, для спасения информации), поскольку данные на поврежденных страницах будут утеряны.

## Заключение

Данная практическая работа помогает:
- Понять, как настраиваются и работают контрольные точки в PostgreSQL.
- Оценить влияние интенсивности записи на генерацию WAL.
- Сравнить производительность в разных режимах подтверждения транзакций.
- Осознать важность контрольных сумм страниц для сохранения целостности данных и ознакомиться с методами обхода ошибок в случае их повреждения.
```

---
